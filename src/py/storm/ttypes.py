#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import sys
sys.path = ["/".join(__file__.split("/")[:-1]) + "/.."] + sys.path

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class StreamType:
  NORMAL = 1
  FAILURE = 2

  _VALUES_TO_NAMES = {
    1: "NORMAL",
    2: "FAILURE",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 1,
    "FAILURE": 2,
  }

class NullStruct:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NullStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class Grouping:
  """
  Attributes:
   - fields
   - shuffle
   - all
   - none
   - direct
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fields', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'shuffle', (NullStruct, NullStruct.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'all', (NullStruct, NullStruct.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'none', (NullStruct, NullStruct.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'direct', (NullStruct, NullStruct.thrift_spec), None, ), # 5
  )

  def __init__(self, fields=None, shuffle=None, all=None, none=None, direct=None,):
    self.fields = fields
    self.shuffle = shuffle
    self.all = all
    self.none = none
    self.direct = direct

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fields = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString().decode('utf-8');
            self.fields.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.shuffle = NullStruct()
          self.shuffle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.all = NullStruct()
          self.all.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.none = NullStruct()
          self.none.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.direct = NullStruct()
          self.direct.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Grouping')
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.fields))
      for iter6 in self.fields:
        oprot.writeString(iter6.encode('utf-8'));
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.shuffle != None:
      oprot.writeFieldBegin('shuffle', TType.STRUCT, 2)
      self.shuffle.write(oprot)
      oprot.writeFieldEnd()
    if self.all != None:
      oprot.writeFieldBegin('all', TType.STRUCT, 3)
      self.all.write(oprot)
      oprot.writeFieldEnd()
    if self.none != None:
      oprot.writeFieldBegin('none', TType.STRUCT, 4)
      self.none.write(oprot)
      oprot.writeFieldEnd()
    if self.direct != None:
      oprot.writeFieldBegin('direct', TType.STRUCT, 5)
      self.direct.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class StreamInfo:
  """
  Attributes:
   - output_fields
   - direct
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'output_fields', (TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'direct', None, None, ), # 2
  )

  def __init__(self, output_fields=None, direct=None,):
    self.output_fields = output_fields
    self.direct = direct

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.output_fields = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8');
            self.output_fields.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.direct = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamInfo')
    if self.output_fields != None:
      oprot.writeFieldBegin('output_fields', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.output_fields))
      for iter13 in self.output_fields:
        oprot.writeString(iter13.encode('utf-8'));
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.direct != None:
      oprot.writeFieldBegin('direct', TType.BOOL, 2)
      oprot.writeBool(self.direct)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class ShellComponent:
  """
  Attributes:
   - execution_command
   - script
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'execution_command', None, None, ), # 1
    (2, TType.STRING, 'script', None, None, ), # 2
  )

  def __init__(self, execution_command=None, script=None,):
    self.execution_command = execution_command
    self.script = script

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.execution_command = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.script = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ShellComponent')
    if self.execution_command != None:
      oprot.writeFieldBegin('execution_command', TType.STRING, 1)
      oprot.writeString(self.execution_command.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.script != None:
      oprot.writeFieldBegin('script', TType.STRING, 2)
      oprot.writeString(self.script.encode('utf-8'));
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class ComponentObject:
  """
  Attributes:
   - serialized_java
   - shell
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serialized_java', None, None, ), # 1
    (2, TType.STRUCT, 'shell', (ShellComponent, ShellComponent.thrift_spec), None, ), # 2
  )

  def __init__(self, serialized_java=None, shell=None,):
    self.serialized_java = serialized_java
    self.shell = shell

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serialized_java = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.shell = ShellComponent()
          self.shell.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ComponentObject')
    if self.serialized_java != None:
      oprot.writeFieldBegin('serialized_java', TType.STRING, 1)
      oprot.writeString(self.serialized_java);
      oprot.writeFieldEnd()
    if self.shell != None:
      oprot.writeFieldBegin('shell', TType.STRUCT, 2)
      self.shell.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class ComponentCommon:
  """
  Attributes:
   - streams
   - parallelism_hint
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'streams', (TType.I32,None,TType.STRUCT,(StreamInfo, StreamInfo.thrift_spec)), None, ), # 1
    (2, TType.I32, 'parallelism_hint', None, None, ), # 2
  )

  def __init__(self, streams=None, parallelism_hint=None,):
    self.streams = streams
    self.parallelism_hint = parallelism_hint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.streams = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          for _i18 in xrange(_size14):
            _key19 = iprot.readI32();
            _val20 = StreamInfo()
            _val20.read(iprot)
            self.streams[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.parallelism_hint = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ComponentCommon')
    if self.streams != None:
      oprot.writeFieldBegin('streams', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.streams))
      for kiter21,viter22 in self.streams.items():
        oprot.writeI32(kiter21)
        viter22.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.parallelism_hint != None:
      oprot.writeFieldBegin('parallelism_hint', TType.I32, 2)
      oprot.writeI32(self.parallelism_hint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class SpoutSpec:
  """
  Attributes:
   - spout_object
   - common
   - distributed
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'spout_object', (ComponentObject, ComponentObject.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'common', (ComponentCommon, ComponentCommon.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'distributed', None, None, ), # 3
  )

  def __init__(self, spout_object=None, common=None, distributed=None,):
    self.spout_object = spout_object
    self.common = common
    self.distributed = distributed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.spout_object = ComponentObject()
          self.spout_object.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.common = ComponentCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.distributed = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SpoutSpec')
    if self.spout_object != None:
      oprot.writeFieldBegin('spout_object', TType.STRUCT, 1)
      self.spout_object.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 2)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    if self.distributed != None:
      oprot.writeFieldBegin('distributed', TType.BOOL, 3)
      oprot.writeBool(self.distributed)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class GlobalStreamId:
  """
  Attributes:
   - componentId
   - streamId
   - streamType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'componentId', None, None, ), # 1
    (2, TType.I32, 'streamId', None, None, ), # 2
    (3, TType.I32, 'streamType', None, None, ), # 3
  )

  def __init__(self, componentId=None, streamId=None, streamType=None,):
    self.componentId = componentId
    self.streamId = streamId
    self.streamType = streamType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.componentId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.streamId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.streamType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GlobalStreamId')
    if self.componentId != None:
      oprot.writeFieldBegin('componentId', TType.I32, 1)
      oprot.writeI32(self.componentId)
      oprot.writeFieldEnd()
    if self.streamId != None:
      oprot.writeFieldBegin('streamId', TType.I32, 2)
      oprot.writeI32(self.streamId)
      oprot.writeFieldEnd()
    if self.streamType != None:
      oprot.writeFieldBegin('streamType', TType.I32, 3)
      oprot.writeI32(self.streamType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class Bolt:
  """
  Attributes:
   - inputs
   - bolt_object
   - common
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'inputs', (TType.STRUCT,(GlobalStreamId, GlobalStreamId.thrift_spec),TType.STRUCT,(Grouping, Grouping.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'bolt_object', (ComponentObject, ComponentObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'common', (ComponentCommon, ComponentCommon.thrift_spec), None, ), # 3
  )

  def __init__(self, inputs=None, bolt_object=None, common=None,):
    self.inputs = inputs
    self.bolt_object = bolt_object
    self.common = common

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.inputs = {}
          (_ktype24, _vtype25, _size23 ) = iprot.readMapBegin() 
          for _i27 in xrange(_size23):
            _key28 = GlobalStreamId()
            _key28.read(iprot)
            _val29 = Grouping()
            _val29.read(iprot)
            self.inputs[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bolt_object = ComponentObject()
          self.bolt_object.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = ComponentCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Bolt')
    if self.inputs != None:
      oprot.writeFieldBegin('inputs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRUCT, TType.STRUCT, len(self.inputs))
      for kiter30,viter31 in self.inputs.items():
        kiter30.write(oprot)
        viter31.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.bolt_object != None:
      oprot.writeFieldBegin('bolt_object', TType.STRUCT, 2)
      self.bolt_object.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class StateSpoutSpec:
  """
  Attributes:
   - state_spout_object
   - common
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'state_spout_object', (ComponentObject, ComponentObject.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'common', (ComponentCommon, ComponentCommon.thrift_spec), None, ), # 2
  )

  def __init__(self, state_spout_object=None, common=None,):
    self.state_spout_object = state_spout_object
    self.common = common

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.state_spout_object = ComponentObject()
          self.state_spout_object.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.common = ComponentCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StateSpoutSpec')
    if self.state_spout_object != None:
      oprot.writeFieldBegin('state_spout_object', TType.STRUCT, 1)
      self.state_spout_object.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 2)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class StormTopology:
  """
  Attributes:
   - spouts
   - bolts
   - state_spouts
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'spouts', (TType.I32,None,TType.STRUCT,(SpoutSpec, SpoutSpec.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'bolts', (TType.I32,None,TType.STRUCT,(Bolt, Bolt.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'state_spouts', (TType.I32,None,TType.STRUCT,(StateSpoutSpec, StateSpoutSpec.thrift_spec)), None, ), # 3
  )

  def __init__(self, spouts=None, bolts=None, state_spouts=None,):
    self.spouts = spouts
    self.bolts = bolts
    self.state_spouts = state_spouts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.spouts = {}
          (_ktype33, _vtype34, _size32 ) = iprot.readMapBegin() 
          for _i36 in xrange(_size32):
            _key37 = iprot.readI32();
            _val38 = SpoutSpec()
            _val38.read(iprot)
            self.spouts[_key37] = _val38
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.bolts = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
          for _i43 in xrange(_size39):
            _key44 = iprot.readI32();
            _val45 = Bolt()
            _val45.read(iprot)
            self.bolts[_key44] = _val45
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.state_spouts = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin() 
          for _i50 in xrange(_size46):
            _key51 = iprot.readI32();
            _val52 = StateSpoutSpec()
            _val52.read(iprot)
            self.state_spouts[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StormTopology')
    if self.spouts != None:
      oprot.writeFieldBegin('spouts', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.spouts))
      for kiter53,viter54 in self.spouts.items():
        oprot.writeI32(kiter53)
        viter54.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.bolts != None:
      oprot.writeFieldBegin('bolts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.bolts))
      for kiter55,viter56 in self.bolts.items():
        oprot.writeI32(kiter55)
        viter56.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.state_spouts != None:
      oprot.writeFieldBegin('state_spouts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.state_spouts))
      for kiter57,viter58 in self.state_spouts.items():
        oprot.writeI32(kiter57)
        viter58.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class AlreadyAliveException(Exception):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AlreadyAliveException')
    if self.msg != None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg.encode('utf-8'));
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class NotAliveException(Exception):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotAliveException')
    if self.msg != None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg.encode('utf-8'));
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class InvalidTopologyException(Exception):
  """
  Attributes:
   - msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'msg', None, None, ), # 1
  )

  def __init__(self, msg=None,):
    self.msg = msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidTopologyException')
    if self.msg != None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg.encode('utf-8'));
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class TopologySummary:
  """
  Attributes:
   - id
   - name
   - num_tasks
   - num_workers
   - uptime_secs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I32, 'num_tasks', None, None, ), # 3
    (4, TType.I32, 'num_workers', None, None, ), # 4
    (5, TType.I32, 'uptime_secs', None, None, ), # 5
  )

  def __init__(self, id=None, name=None, num_tasks=None, num_workers=None, uptime_secs=None,):
    self.id = id
    self.name = name
    self.num_tasks = num_tasks
    self.num_workers = num_workers
    self.uptime_secs = uptime_secs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_tasks = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.num_workers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.uptime_secs = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TopologySummary')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.num_tasks != None:
      oprot.writeFieldBegin('num_tasks', TType.I32, 3)
      oprot.writeI32(self.num_tasks)
      oprot.writeFieldEnd()
    if self.num_workers != None:
      oprot.writeFieldBegin('num_workers', TType.I32, 4)
      oprot.writeI32(self.num_workers)
      oprot.writeFieldEnd()
    if self.uptime_secs != None:
      oprot.writeFieldBegin('uptime_secs', TType.I32, 5)
      oprot.writeI32(self.uptime_secs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class SupervisorSummary:
  """
  Attributes:
   - host
   - uptime_secs
   - num_workers
   - num_used_workers
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.I32, 'uptime_secs', None, None, ), # 2
    (3, TType.I32, 'num_workers', None, None, ), # 3
    (4, TType.I32, 'num_used_workers', None, None, ), # 4
  )

  def __init__(self, host=None, uptime_secs=None, num_workers=None, num_used_workers=None,):
    self.host = host
    self.uptime_secs = uptime_secs
    self.num_workers = num_workers
    self.num_used_workers = num_used_workers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.uptime_secs = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.num_workers = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.num_used_workers = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SupervisorSummary')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.uptime_secs != None:
      oprot.writeFieldBegin('uptime_secs', TType.I32, 2)
      oprot.writeI32(self.uptime_secs)
      oprot.writeFieldEnd()
    if self.num_workers != None:
      oprot.writeFieldBegin('num_workers', TType.I32, 3)
      oprot.writeI32(self.num_workers)
      oprot.writeFieldEnd()
    if self.num_used_workers != None:
      oprot.writeFieldBegin('num_used_workers', TType.I32, 4)
      oprot.writeI32(self.num_used_workers)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class ClusterSummary:
  """
  Attributes:
   - supervisors
   - nimbus_uptime_secs
   - topologies
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'supervisors', (TType.STRUCT,(SupervisorSummary, SupervisorSummary.thrift_spec)), None, ), # 1
    (2, TType.I32, 'nimbus_uptime_secs', None, None, ), # 2
    (3, TType.LIST, 'topologies', (TType.STRUCT,(TopologySummary, TopologySummary.thrift_spec)), None, ), # 3
  )

  def __init__(self, supervisors=None, nimbus_uptime_secs=None, topologies=None,):
    self.supervisors = supervisors
    self.nimbus_uptime_secs = nimbus_uptime_secs
    self.topologies = topologies

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.supervisors = []
          (_etype62, _size59) = iprot.readListBegin()
          for _i63 in xrange(_size59):
            _elem64 = SupervisorSummary()
            _elem64.read(iprot)
            self.supervisors.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.nimbus_uptime_secs = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.topologies = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = TopologySummary()
            _elem70.read(iprot)
            self.topologies.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClusterSummary')
    if self.supervisors != None:
      oprot.writeFieldBegin('supervisors', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.supervisors))
      for iter71 in self.supervisors:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nimbus_uptime_secs != None:
      oprot.writeFieldBegin('nimbus_uptime_secs', TType.I32, 2)
      oprot.writeI32(self.nimbus_uptime_secs)
      oprot.writeFieldEnd()
    if self.topologies != None:
      oprot.writeFieldBegin('topologies', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.topologies))
      for iter72 in self.topologies:
        iter72.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class ErrorInfo:
  """
  Attributes:
   - error
   - error_time_secs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'error', None, None, ), # 1
    (2, TType.I32, 'error_time_secs', None, None, ), # 2
  )

  def __init__(self, error=None, error_time_secs=None,):
    self.error = error
    self.error_time_secs = error_time_secs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.error = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.error_time_secs = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ErrorInfo')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRING, 1)
      oprot.writeString(self.error.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.error_time_secs != None:
      oprot.writeFieldBegin('error_time_secs', TType.I32, 2)
      oprot.writeI32(self.error_time_secs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class BoltStats:
  """
  Attributes:
   - acked
   - failed
   - process_ms_avg
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'acked', (TType.STRING,None,TType.MAP,(TType.STRUCT,(GlobalStreamId, GlobalStreamId.thrift_spec),TType.I64,None)), None, ), # 1
    (2, TType.MAP, 'failed', (TType.STRING,None,TType.MAP,(TType.STRUCT,(GlobalStreamId, GlobalStreamId.thrift_spec),TType.I64,None)), None, ), # 2
    (3, TType.MAP, 'process_ms_avg', (TType.STRING,None,TType.MAP,(TType.STRUCT,(GlobalStreamId, GlobalStreamId.thrift_spec),TType.DOUBLE,None)), None, ), # 3
  )

  def __init__(self, acked=None, failed=None, process_ms_avg=None,):
    self.acked = acked
    self.failed = failed
    self.process_ms_avg = process_ms_avg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.acked = {}
          (_ktype74, _vtype75, _size73 ) = iprot.readMapBegin() 
          for _i77 in xrange(_size73):
            _key78 = iprot.readString().decode('utf-8');
            _val79 = {}
            (_ktype81, _vtype82, _size80 ) = iprot.readMapBegin() 
            for _i84 in xrange(_size80):
              _key85 = GlobalStreamId()
              _key85.read(iprot)
              _val86 = iprot.readI64();
              _val79[_key85] = _val86
            iprot.readMapEnd()
            self.acked[_key78] = _val79
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.failed = {}
          (_ktype88, _vtype89, _size87 ) = iprot.readMapBegin() 
          for _i91 in xrange(_size87):
            _key92 = iprot.readString().decode('utf-8');
            _val93 = {}
            (_ktype95, _vtype96, _size94 ) = iprot.readMapBegin() 
            for _i98 in xrange(_size94):
              _key99 = GlobalStreamId()
              _key99.read(iprot)
              _val100 = iprot.readI64();
              _val93[_key99] = _val100
            iprot.readMapEnd()
            self.failed[_key92] = _val93
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.process_ms_avg = {}
          (_ktype102, _vtype103, _size101 ) = iprot.readMapBegin() 
          for _i105 in xrange(_size101):
            _key106 = iprot.readString().decode('utf-8');
            _val107 = {}
            (_ktype109, _vtype110, _size108 ) = iprot.readMapBegin() 
            for _i112 in xrange(_size108):
              _key113 = GlobalStreamId()
              _key113.read(iprot)
              _val114 = iprot.readDouble();
              _val107[_key113] = _val114
            iprot.readMapEnd()
            self.process_ms_avg[_key106] = _val107
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BoltStats')
    if self.acked != None:
      oprot.writeFieldBegin('acked', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.acked))
      for kiter115,viter116 in self.acked.items():
        oprot.writeString(kiter115.encode('utf-8'));
        oprot.writeMapBegin(TType.STRUCT, TType.I64, len(viter116))
        for kiter117,viter118 in viter116.items():
          kiter117.write(oprot)
          oprot.writeI64(viter118)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.failed != None:
      oprot.writeFieldBegin('failed', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.failed))
      for kiter119,viter120 in self.failed.items():
        oprot.writeString(kiter119.encode('utf-8'));
        oprot.writeMapBegin(TType.STRUCT, TType.I64, len(viter120))
        for kiter121,viter122 in viter120.items():
          kiter121.write(oprot)
          oprot.writeI64(viter122)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.process_ms_avg != None:
      oprot.writeFieldBegin('process_ms_avg', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.process_ms_avg))
      for kiter123,viter124 in self.process_ms_avg.items():
        oprot.writeString(kiter123.encode('utf-8'));
        oprot.writeMapBegin(TType.STRUCT, TType.DOUBLE, len(viter124))
        for kiter125,viter126 in viter124.items():
          kiter125.write(oprot)
          oprot.writeDouble(viter126)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class SpoutStats:
  """
  Attributes:
   - acked
   - failed
   - complete_ms_avg
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'acked', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.I64,None)), None, ), # 1
    (2, TType.MAP, 'failed', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.I64,None)), None, ), # 2
    (3, TType.MAP, 'complete_ms_avg', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.DOUBLE,None)), None, ), # 3
  )

  def __init__(self, acked=None, failed=None, complete_ms_avg=None,):
    self.acked = acked
    self.failed = failed
    self.complete_ms_avg = complete_ms_avg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.acked = {}
          (_ktype128, _vtype129, _size127 ) = iprot.readMapBegin() 
          for _i131 in xrange(_size127):
            _key132 = iprot.readString().decode('utf-8');
            _val133 = {}
            (_ktype135, _vtype136, _size134 ) = iprot.readMapBegin() 
            for _i138 in xrange(_size134):
              _key139 = iprot.readI32();
              _val140 = iprot.readI64();
              _val133[_key139] = _val140
            iprot.readMapEnd()
            self.acked[_key132] = _val133
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.failed = {}
          (_ktype142, _vtype143, _size141 ) = iprot.readMapBegin() 
          for _i145 in xrange(_size141):
            _key146 = iprot.readString().decode('utf-8');
            _val147 = {}
            (_ktype149, _vtype150, _size148 ) = iprot.readMapBegin() 
            for _i152 in xrange(_size148):
              _key153 = iprot.readI32();
              _val154 = iprot.readI64();
              _val147[_key153] = _val154
            iprot.readMapEnd()
            self.failed[_key146] = _val147
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.complete_ms_avg = {}
          (_ktype156, _vtype157, _size155 ) = iprot.readMapBegin() 
          for _i159 in xrange(_size155):
            _key160 = iprot.readString().decode('utf-8');
            _val161 = {}
            (_ktype163, _vtype164, _size162 ) = iprot.readMapBegin() 
            for _i166 in xrange(_size162):
              _key167 = iprot.readI32();
              _val168 = iprot.readDouble();
              _val161[_key167] = _val168
            iprot.readMapEnd()
            self.complete_ms_avg[_key160] = _val161
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SpoutStats')
    if self.acked != None:
      oprot.writeFieldBegin('acked', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.acked))
      for kiter169,viter170 in self.acked.items():
        oprot.writeString(kiter169.encode('utf-8'));
        oprot.writeMapBegin(TType.I32, TType.I64, len(viter170))
        for kiter171,viter172 in viter170.items():
          oprot.writeI32(kiter171)
          oprot.writeI64(viter172)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.failed != None:
      oprot.writeFieldBegin('failed', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.failed))
      for kiter173,viter174 in self.failed.items():
        oprot.writeString(kiter173.encode('utf-8'));
        oprot.writeMapBegin(TType.I32, TType.I64, len(viter174))
        for kiter175,viter176 in viter174.items():
          oprot.writeI32(kiter175)
          oprot.writeI64(viter176)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.complete_ms_avg != None:
      oprot.writeFieldBegin('complete_ms_avg', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.complete_ms_avg))
      for kiter177,viter178 in self.complete_ms_avg.items():
        oprot.writeString(kiter177.encode('utf-8'));
        oprot.writeMapBegin(TType.I32, TType.DOUBLE, len(viter178))
        for kiter179,viter180 in viter178.items():
          oprot.writeI32(kiter179)
          oprot.writeDouble(viter180)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class TaskSpecificStats:
  """
  Attributes:
   - bolt
   - spout
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'bolt', (BoltStats, BoltStats.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'spout', (SpoutStats, SpoutStats.thrift_spec), None, ), # 2
  )

  def __init__(self, bolt=None, spout=None,):
    self.bolt = bolt
    self.spout = spout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.bolt = BoltStats()
          self.bolt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spout = SpoutStats()
          self.spout.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskSpecificStats')
    if self.bolt != None:
      oprot.writeFieldBegin('bolt', TType.STRUCT, 1)
      self.bolt.write(oprot)
      oprot.writeFieldEnd()
    if self.spout != None:
      oprot.writeFieldBegin('spout', TType.STRUCT, 2)
      self.spout.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class TaskStats:
  """
  Attributes:
   - emitted
   - transferred
   - specific
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'emitted', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.I64,None)), None, ), # 1
    (2, TType.MAP, 'transferred', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.I64,None)), None, ), # 2
    (3, TType.STRUCT, 'specific', (TaskSpecificStats, TaskSpecificStats.thrift_spec), None, ), # 3
  )

  def __init__(self, emitted=None, transferred=None, specific=None,):
    self.emitted = emitted
    self.transferred = transferred
    self.specific = specific

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.emitted = {}
          (_ktype182, _vtype183, _size181 ) = iprot.readMapBegin() 
          for _i185 in xrange(_size181):
            _key186 = iprot.readString().decode('utf-8');
            _val187 = {}
            (_ktype189, _vtype190, _size188 ) = iprot.readMapBegin() 
            for _i192 in xrange(_size188):
              _key193 = iprot.readI32();
              _val194 = iprot.readI64();
              _val187[_key193] = _val194
            iprot.readMapEnd()
            self.emitted[_key186] = _val187
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.transferred = {}
          (_ktype196, _vtype197, _size195 ) = iprot.readMapBegin() 
          for _i199 in xrange(_size195):
            _key200 = iprot.readString().decode('utf-8');
            _val201 = {}
            (_ktype203, _vtype204, _size202 ) = iprot.readMapBegin() 
            for _i206 in xrange(_size202):
              _key207 = iprot.readI32();
              _val208 = iprot.readI64();
              _val201[_key207] = _val208
            iprot.readMapEnd()
            self.transferred[_key200] = _val201
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.specific = TaskSpecificStats()
          self.specific.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskStats')
    if self.emitted != None:
      oprot.writeFieldBegin('emitted', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.emitted))
      for kiter209,viter210 in self.emitted.items():
        oprot.writeString(kiter209.encode('utf-8'));
        oprot.writeMapBegin(TType.I32, TType.I64, len(viter210))
        for kiter211,viter212 in viter210.items():
          oprot.writeI32(kiter211)
          oprot.writeI64(viter212)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.transferred != None:
      oprot.writeFieldBegin('transferred', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.transferred))
      for kiter213,viter214 in self.transferred.items():
        oprot.writeString(kiter213.encode('utf-8'));
        oprot.writeMapBegin(TType.I32, TType.I64, len(viter214))
        for kiter215,viter216 in viter214.items():
          oprot.writeI32(kiter215)
          oprot.writeI64(viter216)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.specific != None:
      oprot.writeFieldBegin('specific', TType.STRUCT, 3)
      self.specific.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class TaskSummary:
  """
  Attributes:
   - task_id
   - component_id
   - host
   - port
   - uptime_secs
   - errors
   - stats
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'task_id', None, None, ), # 1
    (2, TType.I32, 'component_id', None, None, ), # 2
    (3, TType.STRING, 'host', None, None, ), # 3
    (4, TType.I32, 'port', None, None, ), # 4
    (5, TType.I32, 'uptime_secs', None, None, ), # 5
    (6, TType.LIST, 'errors', (TType.STRUCT,(ErrorInfo, ErrorInfo.thrift_spec)), None, ), # 6
    (7, TType.STRUCT, 'stats', (TaskStats, TaskStats.thrift_spec), None, ), # 7
  )

  def __init__(self, task_id=None, component_id=None, host=None, port=None, uptime_secs=None, errors=None, stats=None,):
    self.task_id = task_id
    self.component_id = component_id
    self.host = host
    self.port = port
    self.uptime_secs = uptime_secs
    self.errors = errors
    self.stats = stats

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.task_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.component_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.uptime_secs = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.errors = []
          (_etype220, _size217) = iprot.readListBegin()
          for _i221 in xrange(_size217):
            _elem222 = ErrorInfo()
            _elem222.read(iprot)
            self.errors.append(_elem222)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.stats = TaskStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskSummary')
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 1)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.component_id != None:
      oprot.writeFieldBegin('component_id', TType.I32, 2)
      oprot.writeI32(self.component_id)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRING, 3)
      oprot.writeString(self.host.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.port != None:
      oprot.writeFieldBegin('port', TType.I32, 4)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.uptime_secs != None:
      oprot.writeFieldBegin('uptime_secs', TType.I32, 5)
      oprot.writeI32(self.uptime_secs)
      oprot.writeFieldEnd()
    if self.errors != None:
      oprot.writeFieldBegin('errors', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.errors))
      for iter223 in self.errors:
        iter223.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stats != None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 7)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

class TopologyInfo:
  """
  Attributes:
   - id
   - name
   - uptime_secs
   - tasks
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I32, 'uptime_secs', None, None, ), # 3
    (4, TType.LIST, 'tasks', (TType.STRUCT,(TaskSummary, TaskSummary.thrift_spec)), None, ), # 4
  )

  def __init__(self, id=None, name=None, uptime_secs=None, tasks=None,):
    self.id = id
    self.name = name
    self.uptime_secs = uptime_secs
    self.tasks = tasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8');
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.uptime_secs = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.tasks = []
          (_etype227, _size224) = iprot.readListBegin()
          for _i228 in xrange(_size224):
            _elem229 = TaskSummary()
            _elem229.read(iprot)
            self.tasks.append(_elem229)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TopologyInfo')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'));
      oprot.writeFieldEnd()
    if self.uptime_secs != None:
      oprot.writeFieldBegin('uptime_secs', TType.I32, 3)
      oprot.writeI32(self.uptime_secs)
      oprot.writeFieldEnd()
    if self.tasks != None:
      oprot.writeFieldBegin('tasks', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.tasks))
      for iter230 in self.tasks:
        iter230.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def union_value(self):
    d = self.__dict__
    for key in d:
      val = d[key]
      if not val is None:
        return val

  def get_set_field(self):
    for attr in self.__dict__:
      if not self.__dict__[attr] is None:
        return attr

  def get_set_field_id(self):
    for idx, tup in enumerate(self.__class__.thrift_spec):
      if tup:
        key = tup[2]
        if not self.__dict__[key] is None:
          return idx

