#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#


module BackType
  module Storm
        class JavaObjectArg < ::Thrift::Union
          include ::Thrift::Struct_Union
          class << self
            def int_arg(val)
              JavaObjectArg.new(:int_arg, val)
            end

            def long_arg(val)
              JavaObjectArg.new(:long_arg, val)
            end

            def string_arg(val)
              JavaObjectArg.new(:string_arg, val)
            end

            def bool_arg(val)
              JavaObjectArg.new(:bool_arg, val)
            end

            def binary_arg(val)
              JavaObjectArg.new(:binary_arg, val)
            end

            def double_arg(val)
              JavaObjectArg.new(:double_arg, val)
            end
          end

          INT_ARG = 1
          LONG_ARG = 2
          STRING_ARG = 3
          BOOL_ARG = 4
          BINARY_ARG = 5
          DOUBLE_ARG = 6

          FIELDS = {
            INT_ARG => {:type => ::Thrift::Types::I32, :name => 'int_arg'},
            LONG_ARG => {:type => ::Thrift::Types::I64, :name => 'long_arg'},
            STRING_ARG => {:type => ::Thrift::Types::STRING, :name => 'string_arg'},
            BOOL_ARG => {:type => ::Thrift::Types::BOOL, :name => 'bool_arg'},
            BINARY_ARG => {:type => ::Thrift::Types::STRING, :name => 'binary_arg', :binary => true},
            DOUBLE_ARG => {:type => ::Thrift::Types::DOUBLE, :name => 'double_arg'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
          end

          ::Thrift::Union.generate_accessors self
        end

        class JavaObject
          include ::Thrift::Struct, ::Thrift::Struct_Union
          FULL_CLASS_NAME = 1
          ARGS_LIST = 2

          FIELDS = {
            FULL_CLASS_NAME => {:type => ::Thrift::Types::STRING, :name => 'full_class_name'},
            ARGS_LIST => {:type => ::Thrift::Types::LIST, :name => 'args_list', :element => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::JavaObjectArg}}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field full_class_name is unset!') unless @full_class_name
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field args_list is unset!') unless @args_list
          end

          ::Thrift::Struct.generate_accessors self
        end

        class NullStruct
          include ::Thrift::Struct, ::Thrift::Struct_Union

          FIELDS = {

          }

          def struct_fields; FIELDS; end

          def validate
          end

          ::Thrift::Struct.generate_accessors self
        end

        class GlobalStreamId
          include ::Thrift::Struct, ::Thrift::Struct_Union
          COMPONENTID = 1
          STREAMID = 2

          FIELDS = {
            COMPONENTID => {:type => ::Thrift::Types::STRING, :name => 'componentId'},
            STREAMID => {:type => ::Thrift::Types::STRING, :name => 'streamId'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field componentId is unset!') unless @componentId
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field streamId is unset!') unless @streamId
          end

          ::Thrift::Struct.generate_accessors self
        end

        class Grouping < ::Thrift::Union
          include ::Thrift::Struct_Union
          class << self
            def fields(val)
              Grouping.new(:fields, val)
            end

            def shuffle(val)
              Grouping.new(:shuffle, val)
            end

            def all(val)
              Grouping.new(:all, val)
            end

            def none(val)
              Grouping.new(:none, val)
            end

            def direct(val)
              Grouping.new(:direct, val)
            end

            def custom_object(val)
              Grouping.new(:custom_object, val)
            end

            def custom_serialized(val)
              Grouping.new(:custom_serialized, val)
            end

            def local_or_shuffle(val)
              Grouping.new(:local_or_shuffle, val)
            end
          end

          FIELDS = 1
          SHUFFLE = 2
          ALL = 3
          NONE = 4
          DIRECT = 5
          CUSTOM_OBJECT = 6
          CUSTOM_SERIALIZED = 7
          LOCAL_OR_SHUFFLE = 8

          FIELDS = {
            FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRING}},
            SHUFFLE => {:type => ::Thrift::Types::STRUCT, :name => 'shuffle', :class => BackType::Storm::NullStruct},
            ALL => {:type => ::Thrift::Types::STRUCT, :name => 'all', :class => BackType::Storm::NullStruct},
            NONE => {:type => ::Thrift::Types::STRUCT, :name => 'none', :class => BackType::Storm::NullStruct},
            DIRECT => {:type => ::Thrift::Types::STRUCT, :name => 'direct', :class => BackType::Storm::NullStruct},
            CUSTOM_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'custom_object', :class => BackType::Storm::JavaObject},
            CUSTOM_SERIALIZED => {:type => ::Thrift::Types::STRING, :name => 'custom_serialized', :binary => true},
            LOCAL_OR_SHUFFLE => {:type => ::Thrift::Types::STRUCT, :name => 'local_or_shuffle', :class => BackType::Storm::NullStruct}
          }

          def struct_fields; FIELDS; end

          def validate
            raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
          end

          ::Thrift::Union.generate_accessors self
        end

        class StreamInfo
          include ::Thrift::Struct, ::Thrift::Struct_Union
          OUTPUT_FIELDS = 1
          DIRECT = 2

          FIELDS = {
            OUTPUT_FIELDS => {:type => ::Thrift::Types::LIST, :name => 'output_fields', :element => {:type => ::Thrift::Types::STRING}},
            DIRECT => {:type => ::Thrift::Types::BOOL, :name => 'direct'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field output_fields is unset!') unless @output_fields
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field direct is unset!') if @direct.nil?
          end

          ::Thrift::Struct.generate_accessors self
        end

        class ShellComponent
          include ::Thrift::Struct, ::Thrift::Struct_Union
          EXECUTION_COMMAND = 1
          SCRIPT = 2

          FIELDS = {
            EXECUTION_COMMAND => {:type => ::Thrift::Types::STRING, :name => 'execution_command'},
            SCRIPT => {:type => ::Thrift::Types::STRING, :name => 'script'}
          }

          def struct_fields; FIELDS; end

          def validate
          end

          ::Thrift::Struct.generate_accessors self
        end

        class ComponentObject < ::Thrift::Union
          include ::Thrift::Struct_Union
          class << self
            def serialized_java(val)
              ComponentObject.new(:serialized_java, val)
            end

            def shell(val)
              ComponentObject.new(:shell, val)
            end

            def java_object(val)
              ComponentObject.new(:java_object, val)
            end
          end

          SERIALIZED_JAVA = 1
          SHELL = 2
          JAVA_OBJECT = 3

          FIELDS = {
            SERIALIZED_JAVA => {:type => ::Thrift::Types::STRING, :name => 'serialized_java', :binary => true},
            SHELL => {:type => ::Thrift::Types::STRUCT, :name => 'shell', :class => BackType::Storm::ShellComponent},
            JAVA_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'java_object', :class => BackType::Storm::JavaObject}
          }

          def struct_fields; FIELDS; end

          def validate
            raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
          end

          ::Thrift::Union.generate_accessors self
        end

        class ComponentCommon
          include ::Thrift::Struct, ::Thrift::Struct_Union
          INPUTS = 1
          STREAMS = 2
          PARALLELISM_HINT = 3
          JSON_CONF = 4

          FIELDS = {
            INPUTS => {:type => ::Thrift::Types::MAP, :name => 'inputs', :key => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::Grouping}},
            STREAMS => {:type => ::Thrift::Types::MAP, :name => 'streams', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::StreamInfo}},
            PARALLELISM_HINT => {:type => ::Thrift::Types::I32, :name => 'parallelism_hint', :optional => true},
            JSON_CONF => {:type => ::Thrift::Types::STRING, :name => 'json_conf', :optional => true}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field inputs is unset!') unless @inputs
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field streams is unset!') unless @streams
          end

          ::Thrift::Struct.generate_accessors self
        end

        class SpoutSpec
          include ::Thrift::Struct, ::Thrift::Struct_Union
          SPOUT_OBJECT = 1
          COMMON = 2

          FIELDS = {
            SPOUT_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'spout_object', :class => BackType::Storm::ComponentObject},
            COMMON => {:type => ::Thrift::Types::STRUCT, :name => 'common', :class => BackType::Storm::ComponentCommon}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field spout_object is unset!') unless @spout_object
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field common is unset!') unless @common
          end

          ::Thrift::Struct.generate_accessors self
        end

        class Bolt
          include ::Thrift::Struct, ::Thrift::Struct_Union
          BOLT_OBJECT = 1
          COMMON = 2

          FIELDS = {
            BOLT_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'bolt_object', :class => BackType::Storm::ComponentObject},
            COMMON => {:type => ::Thrift::Types::STRUCT, :name => 'common', :class => BackType::Storm::ComponentCommon}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bolt_object is unset!') unless @bolt_object
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field common is unset!') unless @common
          end

          ::Thrift::Struct.generate_accessors self
        end

        class StateSpoutSpec
          include ::Thrift::Struct, ::Thrift::Struct_Union
          STATE_SPOUT_OBJECT = 1
          COMMON = 2

          FIELDS = {
            STATE_SPOUT_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'state_spout_object', :class => BackType::Storm::ComponentObject},
            COMMON => {:type => ::Thrift::Types::STRUCT, :name => 'common', :class => BackType::Storm::ComponentCommon}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state_spout_object is unset!') unless @state_spout_object
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field common is unset!') unless @common
          end

          ::Thrift::Struct.generate_accessors self
        end

        class StormTopology
          include ::Thrift::Struct, ::Thrift::Struct_Union
          SPOUTS = 1
          BOLTS = 2
          STATE_SPOUTS = 3

          FIELDS = {
            SPOUTS => {:type => ::Thrift::Types::MAP, :name => 'spouts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::SpoutSpec}},
            BOLTS => {:type => ::Thrift::Types::MAP, :name => 'bolts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::Bolt}},
            STATE_SPOUTS => {:type => ::Thrift::Types::MAP, :name => 'state_spouts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::StateSpoutSpec}}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field spouts is unset!') unless @spouts
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bolts is unset!') unless @bolts
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state_spouts is unset!') unless @state_spouts
          end

          ::Thrift::Struct.generate_accessors self
        end

        class AlreadyAliveException < ::Thrift::Exception
          include ::Thrift::Struct, ::Thrift::Struct_Union
          def initialize(message=nil)
            super()
            self.msg = message
          end

          def message; msg end

          MSG = 1

          FIELDS = {
            MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
          end

          ::Thrift::Struct.generate_accessors self
        end

        class NotAliveException < ::Thrift::Exception
          include ::Thrift::Struct, ::Thrift::Struct_Union
          def initialize(message=nil)
            super()
            self.msg = message
          end

          def message; msg end

          MSG = 1

          FIELDS = {
            MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
          end

          ::Thrift::Struct.generate_accessors self
        end

        class InvalidTopologyException < ::Thrift::Exception
          include ::Thrift::Struct, ::Thrift::Struct_Union
          def initialize(message=nil)
            super()
            self.msg = message
          end

          def message; msg end

          MSG = 1

          FIELDS = {
            MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
          end

          ::Thrift::Struct.generate_accessors self
        end

        class TopologySummary
          include ::Thrift::Struct, ::Thrift::Struct_Union
          ID = 1
          NAME = 2
          NUM_TASKS = 3
          NUM_WORKERS = 4
          UPTIME_SECS = 5
          STATUS = 6

          FIELDS = {
            ID => {:type => ::Thrift::Types::STRING, :name => 'id'},
            NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
            NUM_TASKS => {:type => ::Thrift::Types::I32, :name => 'num_tasks'},
            NUM_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_workers'},
            UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
            STATUS => {:type => ::Thrift::Types::STRING, :name => 'status'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_tasks is unset!') unless @num_tasks
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_workers is unset!') unless @num_workers
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
          end

          ::Thrift::Struct.generate_accessors self
        end

        class SupervisorSummary
          include ::Thrift::Struct, ::Thrift::Struct_Union
          HOST = 1
          UPTIME_SECS = 2
          NUM_WORKERS = 3
          NUM_USED_WORKERS = 4

          FIELDS = {
            HOST => {:type => ::Thrift::Types::STRING, :name => 'host'},
            UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
            NUM_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_workers'},
            NUM_USED_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_used_workers'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field host is unset!') unless @host
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_workers is unset!') unless @num_workers
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_used_workers is unset!') unless @num_used_workers
          end

          ::Thrift::Struct.generate_accessors self
        end

        class ClusterSummary
          include ::Thrift::Struct, ::Thrift::Struct_Union
          SUPERVISORS = 1
          NIMBUS_UPTIME_SECS = 2
          TOPOLOGIES = 3

          FIELDS = {
            SUPERVISORS => {:type => ::Thrift::Types::LIST, :name => 'supervisors', :element => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::SupervisorSummary}},
            NIMBUS_UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'nimbus_uptime_secs'},
            TOPOLOGIES => {:type => ::Thrift::Types::LIST, :name => 'topologies', :element => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::TopologySummary}}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field supervisors is unset!') unless @supervisors
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nimbus_uptime_secs is unset!') unless @nimbus_uptime_secs
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field topologies is unset!') unless @topologies
          end

          ::Thrift::Struct.generate_accessors self
        end

        class ErrorInfo
          include ::Thrift::Struct, ::Thrift::Struct_Union
          ERROR = 1
          ERROR_TIME_SECS = 2

          FIELDS = {
            ERROR => {:type => ::Thrift::Types::STRING, :name => 'error'},
            ERROR_TIME_SECS => {:type => ::Thrift::Types::I32, :name => 'error_time_secs'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field error is unset!') unless @error
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field error_time_secs is unset!') unless @error_time_secs
          end

          ::Thrift::Struct.generate_accessors self
        end

        class BoltStats
          include ::Thrift::Struct, ::Thrift::Struct_Union
          ACKED = 1
          FAILED = 2
          PROCESS_MS_AVG = 3

          FIELDS = {
            ACKED => {:type => ::Thrift::Types::MAP, :name => 'acked', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::I64}}},
            FAILED => {:type => ::Thrift::Types::MAP, :name => 'failed', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::I64}}},
            PROCESS_MS_AVG => {:type => ::Thrift::Types::MAP, :name => 'process_ms_avg', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::DOUBLE}}}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field acked is unset!') unless @acked
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field failed is unset!') unless @failed
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field process_ms_avg is unset!') unless @process_ms_avg
          end

          ::Thrift::Struct.generate_accessors self
        end

        class SpoutStats
          include ::Thrift::Struct, ::Thrift::Struct_Union
          ACKED = 1
          FAILED = 2
          COMPLETE_MS_AVG = 3

          FIELDS = {
            ACKED => {:type => ::Thrift::Types::MAP, :name => 'acked', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
            FAILED => {:type => ::Thrift::Types::MAP, :name => 'failed', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
            COMPLETE_MS_AVG => {:type => ::Thrift::Types::MAP, :name => 'complete_ms_avg', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::DOUBLE}}}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field acked is unset!') unless @acked
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field failed is unset!') unless @failed
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field complete_ms_avg is unset!') unless @complete_ms_avg
          end

          ::Thrift::Struct.generate_accessors self
        end

        class TaskSpecificStats < ::Thrift::Union
          include ::Thrift::Struct_Union
          class << self
            def bolt(val)
              TaskSpecificStats.new(:bolt, val)
            end

            def spout(val)
              TaskSpecificStats.new(:spout, val)
            end
          end

          BOLT = 1
          SPOUT = 2

          FIELDS = {
            BOLT => {:type => ::Thrift::Types::STRUCT, :name => 'bolt', :class => BackType::Storm::BoltStats},
            SPOUT => {:type => ::Thrift::Types::STRUCT, :name => 'spout', :class => BackType::Storm::SpoutStats}
          }

          def struct_fields; FIELDS; end

          def validate
            raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
          end

          ::Thrift::Union.generate_accessors self
        end

        class TaskStats
          include ::Thrift::Struct, ::Thrift::Struct_Union
          EMITTED = 1
          TRANSFERRED = 2
          SPECIFIC = 3

          FIELDS = {
            EMITTED => {:type => ::Thrift::Types::MAP, :name => 'emitted', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
            TRANSFERRED => {:type => ::Thrift::Types::MAP, :name => 'transferred', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
            SPECIFIC => {:type => ::Thrift::Types::STRUCT, :name => 'specific', :class => BackType::Storm::TaskSpecificStats}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field emitted is unset!') unless @emitted
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field transferred is unset!') unless @transferred
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field specific is unset!') unless @specific
          end

          ::Thrift::Struct.generate_accessors self
        end

        class TaskSummary
          include ::Thrift::Struct, ::Thrift::Struct_Union
          TASK_ID = 1
          COMPONENT_ID = 2
          HOST = 3
          PORT = 4
          UPTIME_SECS = 5
          STATS = 7

          FIELDS = {
            TASK_ID => {:type => ::Thrift::Types::I32, :name => 'task_id'},
            COMPONENT_ID => {:type => ::Thrift::Types::STRING, :name => 'component_id'},
            HOST => {:type => ::Thrift::Types::STRING, :name => 'host'},
            PORT => {:type => ::Thrift::Types::I32, :name => 'port'},
            UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
            STATS => {:type => ::Thrift::Types::STRUCT, :name => 'stats', :class => BackType::Storm::TaskStats, :optional => true}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field task_id is unset!') unless @task_id
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field component_id is unset!') unless @component_id
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field host is unset!') unless @host
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field port is unset!') unless @port
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
          end

          ::Thrift::Struct.generate_accessors self
        end

        class TopologyInfo
          include ::Thrift::Struct, ::Thrift::Struct_Union
          ID = 1
          NAME = 2
          UPTIME_SECS = 3
          TASKS = 4
          STATUS = 5
          ERRORS = 6

          FIELDS = {
            ID => {:type => ::Thrift::Types::STRING, :name => 'id'},
            NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
            UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
            TASKS => {:type => ::Thrift::Types::LIST, :name => 'tasks', :element => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::TaskSummary}},
            STATUS => {:type => ::Thrift::Types::STRING, :name => 'status'},
            ERRORS => {:type => ::Thrift::Types::MAP, :name => 'errors', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => BackType::Storm::ErrorInfo}}}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tasks is unset!') unless @tasks
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field errors is unset!') unless @errors
          end

          ::Thrift::Struct.generate_accessors self
        end

        class KillOptions
          include ::Thrift::Struct, ::Thrift::Struct_Union
          WAIT_SECS = 1

          FIELDS = {
            WAIT_SECS => {:type => ::Thrift::Types::I32, :name => 'wait_secs', :optional => true}
          }

          def struct_fields; FIELDS; end

          def validate
          end

          ::Thrift::Struct.generate_accessors self
        end

        class RebalanceOptions
          include ::Thrift::Struct, ::Thrift::Struct_Union
          WAIT_SECS = 1
          NUM_WORKERS = 2
          NUM_EXECUTORS = 3

          FIELDS = {
            WAIT_SECS => {:type => ::Thrift::Types::I32, :name => 'wait_secs', :optional => true},
            NUM_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_workers', :optional => true},
            NUM_EXECUTORS => {:type => ::Thrift::Types::MAP, :name => 'num_executors', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}, :optional => true}
          }

          def struct_fields; FIELDS; end

          def validate
          end

          ::Thrift::Struct.generate_accessors self
        end

        class DRPCRequest
          include ::Thrift::Struct, ::Thrift::Struct_Union
          FUNC_ARGS = 1
          REQUEST_ID = 2

          FIELDS = {
            FUNC_ARGS => {:type => ::Thrift::Types::STRING, :name => 'func_args'},
            REQUEST_ID => {:type => ::Thrift::Types::STRING, :name => 'request_id'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field func_args is unset!') unless @func_args
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field request_id is unset!') unless @request_id
          end

          ::Thrift::Struct.generate_accessors self
        end

        class DRPCExecutionException < ::Thrift::Exception
          include ::Thrift::Struct, ::Thrift::Struct_Union
          def initialize(message=nil)
            super()
            self.msg = message
          end

          def message; msg end

          MSG = 1

          FIELDS = {
            MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
          }

          def struct_fields; FIELDS; end

          def validate
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
          end

          ::Thrift::Struct.generate_accessors self
        end

      end
    end
